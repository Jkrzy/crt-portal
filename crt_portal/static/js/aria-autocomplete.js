a(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/aria-autocomplete.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/element-addclass/dist/element-addclass.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/element-addclass/dist/element-addclass.mjs ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return e; });\nvar t=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;function e(r,n){if(r&&1===r.nodeType&&\"string\"==typeof n)!function(e,r){for(var n=e.getAttribute&&e.getAttribute(\"class\")||\"\",l=\" \"+n+\" \",f=\"\",i=0,s=r.split(\" \"),u=s.length;i<u;i+=1)\"\"!==s[i]&&-1===l.indexOf(\" \"+s[i]+\" \")&&(f+=\" \"+s[i]);var a;n!==(f=null==(a=n+f)?\"\":(a+\"\").replace(t,\"\"))&&e.setAttribute(\"class\",f)}(r,n);else if(r&&\"number\"==typeof r.length)for(var l=0,f=r.length;l<f;l+=1)e(r[l],n)}\n\n\n//# sourceURL=webpack:///./node_modules/element-addclass/dist/element-addclass.mjs?");

/***/ }),

/***/ "./node_modules/element-removeclass/dist/element-removeclass.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/element-removeclass/dist/element-removeclass.mjs ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return e; });\nvar t=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;function e(r,l){if(r&&1===r.nodeType&&\"string\"==typeof l)!function(e,r){for(var l=e.getAttribute&&e.getAttribute(\"class\")||\"\",n=\" \"+l+\" \",s=0,u=r.split(\" \"),a=u.length;s<a;s+=1)n=n.replace(\" \"+u[s]+\" \",\" \");var f;l!==(n=null==(f=n)?\"\":(f+\"\").replace(t,\"\"))&&e.setAttribute(\"class\",n)}(r,l);else if(r&&\"number\"==typeof r.length)for(var n=0,s=r.length;n<s;n+=1)e(r[n],l)}\n\n\n//# sourceURL=webpack:///./node_modules/element-removeclass/dist/element-removeclass.mjs?");

/***/ }),

/***/ "./node_modules/input-autowidth/dist/input-autowidth.min.js":
/*!******************************************************************!*\
  !*** ./node_modules/input-autowidth/dist/input-autowidth.min.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(t,e){if(true)module.exports=e();else { var i, n; }}(window,(function(){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var r in t)n.d(i,r,function(e){return t[e]}.bind(null,r));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=0)}([function(t,e,n){\"use strict\";n.r(e);var i;function r(t,e){if(t)for(var n in e){var i=\"number\"==typeof e[n]?e[n]+\"px\":e[n];t.style[n]=i+\"\"}}n.d(e,\"InputAutoWidth\",(function(){return o}));var o=function(){function t(t,e){this.cache={},this.options=e,this.input=t,this.trigger(),this.eventHandler=this.trigger.bind(this),this.input.addEventListener(\"blur\",this.eventHandler),this.input.addEventListener(\"input\",this.eventHandler),this.input.addEventListener(\"keyup\",this.eventHandler),this.input.addEventListener(\"keydown\",this.eventHandler)}return t.prototype.measureString=function(t){return t?this.cache&&\"number\"==typeof this.cache[t]?this.cache[t]:(i||(r(i=document.createElement(\"span\"),{position:\"absolute\",top:-99999,left:-99999,width:\"auto\",padding:0,whiteSpace:\"pre\"}),document.body.appendChild(i)),i.textContent=t,function(t,e,n){if(t&&e){var i=getComputedStyle(t),o={};if(n&&n.length)for(var s=0,u=n.length;s<u;s+=1)o[n[s]]=i[n[s]];else o=i;r(e,o)}}(this.input,i,[\"letterSpacing\",\"fontSize\",\"fontFamily\",\"fontWeight\",\"textTransform\"]),i.offsetWidth||i.clientWidth):0},t.prototype.trigger=function(t){if(void 0===t&&(t={}),!t.metaKey&&!t.altKey){var e,n,i=this.input.value;if(t.type&&\"keydown\"===t.type.toLowerCase()){var r=t.keyCode,o=46===r,s=8===r;if(o||s){var u=function(t){var e={};if(\"selectionStart\"in t)e.start=t.selectionStart,e.length=t.selectionEnd-e.start;else if(document.selection){t.focus();var n=document.selection.createRange(),i=n.text.length;n.moveStart(\"character\",-t.value.length),e.start=n.text.length-i,e.length=i}return e}(this.input);u.length?i=i.substring(0,u.start)+i.substring(u.start+u.length):s&&u.start?i=i.substring(0,u.start-1)+i.substring(u.start+1):o&&void 0!==u.start&&(i=i.substring(0,u.start)+i.substring(u.start+1))}else if((e=r)>=48&&e<=57||e>=65&&e<=90||e>=96&&e<=111||e>=186&&e<=222||32===e||8===e||46===e){var a=String.fromCharCode(r);i+=a=t.shiftKey?a.toUpperCase():a.toLowerCase()}}!i&&(n=this.input.getAttribute(\"placeholder\"))&&(i=n);var h=this.measureString(i)+4;this.options&&this.options.cache&&this.cache&&(this.cache[i]=h);var p=this.options&&this.options.minWidth;\"number\"==typeof p&&h<p&&(h=p);var c=this.options&&this.options.maxWidth;\"number\"==typeof c&&h>c&&(h=c),h!==this.currentWidth&&(this.currentWidth=h,this.input.style.width=h+\"px\")}},t.prototype.destroy=function(){this.input.removeEventListener(\"blur\",this.eventHandler),this.input.removeEventListener(\"input\",this.eventHandler),this.input.removeEventListener(\"keyup\",this.eventHandler),this.input.removeEventListener(\"keydown\",this.eventHandler),this.input=this.cache=null},t}();e.default=o}])}));\n\n//# sourceURL=webpack:///./node_modules/input-autowidth/dist/input-autowidth.min.js?");

/***/ }),

/***/ "./node_modules/is-printable-keycode/dist/is-printable-keycode.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/is-printable-keycode/dist/is-printable-keycode.mjs ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(t){return t>=48&&t<=57||t>=65&&t<=90||t>=96&&t<=111||t>=186&&t<=222||32===t||8===t||46===t});\n\n\n//# sourceURL=webpack:///./node_modules/is-printable-keycode/dist/is-printable-keycode.mjs?");

/***/ }),

/***/ "./src/aria-autocomplete.ts":
/*!**********************************!*\
  !*** ./src/aria-autocomplete.ts ***!
  \**********************************/
/*! exports provided: AriaAutocomplete, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AriaAutocomplete\", function() { return AriaAutocomplete; });\n/* harmony import */ var _autocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autocomplete */ \"./src/autocomplete.ts\");\n/* harmony import */ var _autocomplete_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./autocomplete-constants */ \"./src/autocomplete-constants.ts\");\n\n\nfunction AriaAutocomplete(element, options) {\n    // if instance already exists on the main element, do not re-initialise\n    if (element && element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_1__[\"API_STORAGE_PROP\"]] && element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_1__[\"API_STORAGE_PROP\"]].open) {\n        return element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_1__[\"API_STORAGE_PROP\"]];\n    }\n    return new _autocomplete__WEBPACK_IMPORTED_MODULE_0__[\"default\"](element, options).api;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AriaAutocomplete);\n\n\n//# sourceURL=webpack:///./src/aria-autocomplete.ts?");

/***/ }),

/***/ "./src/autocomplete-api.ts":
/*!*********************************!*\
  !*** ./src/autocomplete-api.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autocomplete-constants */ \"./src/autocomplete-constants.ts\");\n\n// generate Tablist API to expose to users\nvar AutocompleteApi = /** @class */ (function () {\n    // provide Tablist instance\n    function AutocompleteApi(instance) {\n        this.list = instance.list;\n        this.input = instance.input;\n        this.wrapper = instance.wrapper;\n        this.options = instance.options;\n        this.selected = instance.selected;\n        // bind to Autocomplete instance to keep it private\n        this.open = this.open.bind(instance);\n        this.close = this.close.bind(instance);\n        this.enable = this.enable.bind(instance);\n        this.disable = this.disable.bind(instance);\n        this.filter = this.filter.bind(instance);\n        this.destroy = this.destroy.bind(instance);\n        // store API on the Tablist element\n        instance.element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__[\"API_STORAGE_PROP\"]] = this;\n    }\n    AutocompleteApi.prototype.open = function () {\n        this.show.call(this);\n    };\n    AutocompleteApi.prototype.close = function () {\n        this.hide.call(this);\n    };\n    AutocompleteApi.prototype.enable = function () {\n        this.enable.call(this);\n    };\n    AutocompleteApi.prototype.disable = function (disableDeletions) {\n        this.disable.call(this, disableDeletions);\n    };\n    AutocompleteApi.prototype.filter = function (val) {\n        this.filter.call(this, val);\n    };\n    AutocompleteApi.prototype.destroy = function () {\n        this.destroy.call(this);\n    };\n    return AutocompleteApi;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (AutocompleteApi);\n\n\n//# sourceURL=webpack:///./src/autocomplete-api.ts?");

/***/ }),

/***/ "./src/autocomplete-constants.ts":
/*!***************************************!*\
  !*** ./src/autocomplete-constants.ts ***!
  \***************************************/
/*! exports provided: API_STORAGE_PROP, CLEANED_LABEL_PROP, SELECTED_OPTION_PROP, ORIGINALLY_LABEL_FOR_PROP, KEYCODES, UNESCAPED_HTML_REGEX, HTML_REPLACEMENTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_STORAGE_PROP\", function() { return API_STORAGE_PROP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CLEANED_LABEL_PROP\", function() { return CLEANED_LABEL_PROP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECTED_OPTION_PROP\", function() { return SELECTED_OPTION_PROP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ORIGINALLY_LABEL_FOR_PROP\", function() { return ORIGINALLY_LABEL_FOR_PROP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYCODES\", function() { return KEYCODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UNESCAPED_HTML_REGEX\", function() { return UNESCAPED_HTML_REGEX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTML_REPLACEMENTS\", function() { return HTML_REPLACEMENTS; });\nvar API_STORAGE_PROP = 'ariaAutocomplete';\nvar CLEANED_LABEL_PROP = '_ariaAutocompleteCleanedLabel';\nvar SELECTED_OPTION_PROP = '_ariaAutocompleteSelectedOption';\nvar ORIGINALLY_LABEL_FOR_PROP = '_ariaAutocompleteLabelOriginallyFor';\nvar KEYCODES = {\n    BACKSPACE: 8,\n    ENTER: 13,\n    ESCAPE: 27,\n    SPACE: 32,\n    PAGEUP: 33,\n    PAGEDOWN: 34,\n    END: 35,\n    HOME: 36,\n    UP: 38,\n    DOWN: 40,\n    DELETE: 46,\n};\nvar UNESCAPED_HTML_REGEX = /[&<>\"']/g;\nvar HTML_REPLACEMENTS = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\n\n\n//# sourceURL=webpack:///./src/autocomplete-constants.ts?");

/***/ }),

/***/ "./src/autocomplete-helpers.ts":
/*!*************************************!*\
  !*** ./src/autocomplete-helpers.ts ***!
  \*************************************/
/*! exports provided: trimString, escapeHtml, cleanString, mergeObjects, dispatchEvent, getChildrenOf, setElementState, processSourceEntry, processSourceArray, searchSourceEntryFor, prepSearchInArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimString\", function() { return trimString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"escapeHtml\", function() { return escapeHtml; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cleanString\", function() { return cleanString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeObjects\", function() { return mergeObjects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dispatchEvent\", function() { return dispatchEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getChildrenOf\", function() { return getChildrenOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setElementState\", function() { return setElementState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processSourceEntry\", function() { return processSourceEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processSourceArray\", function() { return processSourceArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"searchSourceEntryFor\", function() { return searchSourceEntryFor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepSearchInArray\", function() { return prepSearchInArray; });\n/* harmony import */ var _autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autocomplete-constants */ \"./src/autocomplete-constants.ts\");\n\n/**\n * remove start and end whitespace from string\n */\nfunction trimString(theString) {\n    return theString == null ? '' : (theString + '').trim();\n}\n/**\n * convert &, <, >, \", and ' in a string to their HTML entities\n */\nfunction escapeHtml(value) {\n    if (typeof value !== 'string' || !value) {\n        return '';\n    }\n    return value.replace(_autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__[\"UNESCAPED_HTML_REGEX\"], function (character) { return _autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__[\"HTML_REPLACEMENTS\"][character]; });\n}\nvar REGEX_AMPERSAND = /&/g;\nvar REGEX_DUPE_WHITESPACE = /\\s\\s+/g;\nvar REGEX_TO_IGNORE = /[\\u2018\\u2019',:\\u2013-]/g;\nvar REGEX_MAKE_SAFE = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n/**\n * clean a string to make searchable\n */\nfunction cleanString(theString, makeSafeForRegex) {\n    if (makeSafeForRegex === void 0) { makeSafeForRegex = false; }\n    theString = trimString(theString)\n        .toLowerCase() // case insensitive\n        .replace(REGEX_TO_IGNORE, '') // ignore quotes, commas, colons, and hyphens\n        .replace(REGEX_AMPERSAND, 'and') // treat & and 'and' as the same\n        .replace(REGEX_DUPE_WHITESPACE, ' '); // ignore duplicate whitespace\n    // make safe for regex searching\n    if (makeSafeForRegex) {\n        theString = theString.replace(REGEX_MAKE_SAFE, '\\\\$&');\n    }\n    return theString;\n}\n/**\n * merge objects together to generate a new one\n */\nfunction mergeObjects() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var result = {};\n    args.forEach(function (obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop) && typeof obj[prop] !== 'undefined') {\n                result[prop] = obj[prop];\n            }\n        }\n    });\n    return result;\n}\n/**\n * trigger an event on an element\n */\nfunction dispatchEvent(element, event) {\n    if ('createEvent' in document) {\n        var htmlEvents = document.createEvent('HTMLEvents');\n        htmlEvents.initEvent(event, true, true);\n        element.dispatchEvent(htmlEvents);\n    }\n    else {\n        element.fireEvent('on' + event);\n    }\n}\n/**\n * get element children as an Array\n */\nfunction getChildrenOf(element) {\n    if (!element || !element.children) {\n        return [];\n    }\n    return Array.prototype.slice.call(element.children);\n}\n/**\n * set element option or checkbox to specified state and trigger change event\n */\nfunction setElementState(element, selected, instance) {\n    selected = !!selected;\n    if (element) {\n        // handle checkbox\n        if (element.nodeName === 'INPUT' && 'checked' in element && element.checked !== selected) {\n            element.checked = selected;\n            dispatchEvent(element, 'change');\n        }\n        // handle dropdown option\n        if (element.nodeName === 'OPTION' && 'selected' in element && element.selected !== selected) {\n            element.selected = selected;\n            // ensure change event only fires once for dropdown\n            clearTimeout(instance.elementChangeEventTimer);\n            instance.elementChangeEventTimer = setTimeout(function () {\n                dispatchEvent(element.closest('select'), 'change');\n            }, 1);\n        }\n    }\n}\n/**\n * process a results entry string or object to ensure needed props exist\n */\nfunction processSourceEntry(entry, mapping) {\n    if (mapping === void 0) { mapping = {}; }\n    var result = {};\n    var mapValue = mapping['value'];\n    var mapLabel = mapping['label'];\n    if (typeof entry === 'string') {\n        result.value = result.label = entry;\n    }\n    else {\n        // generate new object to not modify original\n        // ensure value and label exist, and maintain any other properties\n        result = mergeObjects(entry);\n        result.value = (result[mapValue] || result.value || result.label || '').toString();\n        result.label = (result[mapLabel] || result.label || result.value || '').toString();\n    }\n    // set a cleaned label for static source filtering (in filter method)\n    result[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__[\"CLEANED_LABEL_PROP\"]] = cleanString(result.label);\n    return result;\n}\n/**\n * process an array of strings or objects to ensure needed props exist\n */\nfunction processSourceArray(sourceArray, mapping) {\n    if (mapping === void 0) { mapping = {}; }\n    if (!Array.isArray(sourceArray)) {\n        return sourceArray ? [sourceArray] : [];\n    }\n    return sourceArray.map(function (entry) { return processSourceEntry(entry, mapping); });\n}\n/**\n * check if string contains text (partial, safe match)\n */\nfunction searchStringFor(toCheck, toSearchFor, name) {\n    if (name !== _autocomplete_constants__WEBPACK_IMPORTED_MODULE_0__[\"CLEANED_LABEL_PROP\"]) {\n        toCheck = cleanString(toCheck, false);\n    }\n    return toCheck.search(toSearchFor) !== -1;\n}\n/**\n * search String or Array for another string - partial match\n */\nfunction searchPropFor(prop, toSearchFor, name) {\n    if (typeof prop === 'string') {\n        return searchStringFor(prop, toSearchFor, name);\n    }\n    if (Array.isArray(prop)) {\n        for (var i = 0, l = prop.length; i < l; i += 1) {\n            if (searchPropFor(prop[i], toSearchFor)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * check through object's String or String[] properties for query match\n */\nfunction searchSourceEntryFor(toSearchIn, toSearchFor, propsToSearch) {\n    for (var i in toSearchIn) {\n        if (!toSearchIn.hasOwnProperty(i)) {\n            continue;\n        }\n        var entry = toSearchIn[i];\n        // allow searching only on strings and arrays\n        var proceed = (typeof entry === 'string' || Array.isArray(entry)) && propsToSearch.indexOf(i) > -1;\n        if (proceed && searchPropFor(entry, toSearchFor, i)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * remove duplicate array entries, and `label`\n */\nfunction prepSearchInArray(arr) {\n    // remove `label` (we will be using CLEANED_LABEL_PROP) and duplicates from props array\n    var result = [];\n    arr.forEach(function (entry) {\n        if (typeof entry !== 'string') {\n            return;\n        }\n        // check that the array entry is not 'label' first\n        var str = trimString(entry);\n        var proceed = str !== 'label';\n        // now check through result array to make sure it is not a duplicate\n        for (var i = 0, l = result.length; proceed && i < l; i += 1) {\n            proceed = result[l] !== str;\n        }\n        if (proceed) {\n            result.push(str);\n        }\n    });\n    return result;\n}\n\n\n//# sourceURL=webpack:///./src/autocomplete-helpers.ts?");

/***/ }),

/***/ "./src/autocomplete-ids.ts":
/*!*********************************!*\
  !*** ./src/autocomplete-ids.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// ids used for DOM queries and accessibility attributes e.g. aria-controls\nvar index = 0;\nvar default_1 = /** @class */ (function () {\n    function default_1(elementId, labelId, optionId) {\n        index += 1;\n        this.ELEMENT = elementId;\n        var id = optionId || elementId || '';\n        this.PREFIX = id + \"aria-autocomplete-\" + index;\n        this.LIST = this.PREFIX + \"-list\";\n        this.BUTTON = this.PREFIX + \"-button\";\n        this.OPTION = this.PREFIX + \"-option\";\n        this.WRAPPER = this.PREFIX + \"-wrapper\";\n        this.LABEL = labelId || this.PREFIX + \"-label\";\n        this.INPUT = optionId || this.PREFIX + \"-input\";\n        this.SR_ASSISTANCE = this.PREFIX + \"-sr-assistance\";\n        this.OPTION_SELECTED = this.PREFIX + \"-option-selected\";\n        this.SR_ANNOUNCEMENTS = this.PREFIX + \"-sr-announcements\";\n    }\n    return default_1;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (default_1);\n\n\n//# sourceURL=webpack:///./src/autocomplete-ids.ts?");

/***/ }),

/***/ "./src/autocomplete-options.ts":
/*!*************************************!*\
  !*** ./src/autocomplete-options.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar AutocompleteOptions = /** @class */ (function () {\n    /**\n     * constructor\n     */\n    function AutocompleteOptions(options) {\n        if (options === void 0) { options = {}; }\n        /**\n         * Properties to use for label and value when source is an Array of Objects\n         */\n        this.sourceMapping = {};\n        /**\n         * Additional properties to use when searching for a match.\n         * `label` will always be used\n         */\n        this.alsoSearchIn = [];\n        /**\n         * If no exact match is found,\n         * create an entry in the options list for the current search text\n         */\n        this.create = false;\n        /**\n         * Input delay after typing before running a search\n         */\n        this.delay = 100;\n        /**\n         * Minimum number of characters to run a search (includes spaces)\n         */\n        this.minLength = 1;\n        /**\n         * Maximum number of results to render. Also used in async endpoint URL\n         */\n        this.maxResults = 9999;\n        /**\n         * Render a control that triggers showing all options.\n         * Runs a search with an empty query: '', and maxResults of 9999\n         */\n        this.showAllControl = false;\n        /**\n         * Confirm currently active selection when blurring off of the control. If\n         * no active selection, will compare current input value against available labels\n         */\n        this.confirmOnBlur = true;\n        /**\n         * Allow multiple items to be selected\n         */\n        this.multiple = false;\n        /**\n         * Adjust input width to match its value. This will incur a performance hit\n         */\n        this.autoGrow = false;\n        /**\n         * Maximum number of items that can be selected in multiple mode\n         */\n        this.maxItems = 9999;\n        /**\n         * If initialised element is an input, and in multiple mode,\n         * character that separates the selected values e.g. \"GLP,ZWE\"\n         */\n        this.multipleSeparator = \",\";\n        /**\n         * If input is empty and in multiple mode,\n         * delete last selected item on backspace\n         */\n        this.deleteOnBackspace = false;\n        /**\n         * In multiple mode, if more than 1 item is selected,\n         * add a button at the beginning of the selected items as a shortcut to delete all\n         */\n        this.deleteAllControl = false;\n        /**\n         * Text to use in the deleteAllControl\n         */\n        this.deleteAllText = \"Delete all\";\n        /**\n         * In async mode, parameter to use when adding the input value to the\n         * endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\n         */\n        this.asyncQueryParam = \"q\";\n        /**\n         * In async mode, parameter to use when adding results limit to the\n         * endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\n         */\n        this.asyncMaxResultsParam = \"limit\";\n        /**\n         * Text to show (and announce to screen readers) if no results found.\n         * If empty, the list of options will remain hidden when there are no results\n         */\n        this.noResultsText = \"No results\";\n        /**\n         * String to prepend to classes for BEM naming\n         * e.g. aria-autocomplete__input\n         */\n        this.cssNameSpace = \"aria-autocomplete\";\n        /**\n         * Set the delay (in milliseconds) before screen reader announcements are made.\n         * Note: if this is too short, some default announcements may interrupt it,\n         * particularly with screen readers that re-announce input values after a pause in typing.\n         */\n        this.srDelay = 1400;\n        /**\n         * Automatically clear the screen reader announcement element after the specified delay\n         * Number is in milliseconds. If true, defaults to 10000.\n         */\n        this.srAutoClear = 10000;\n        /**\n         * Screen reader text used in multiple mode for element deletion.\n         * Prepended to option label in aria-label attribute e.g. 'delete Canada'\n         */\n        this.srDeleteText = \"delete\";\n        /**\n         * Screen reader text announced after deletion.\n         * Apended to option label e.g. 'Canada deleted'\n         */\n        this.srDeletedText = \"deleted\";\n        /**\n         * Value for aria-label attribute on the show all control\n         */\n        this.srShowAllText = \"Show all\";\n        /**\n         * Screen reader text announced after confirming a selection.\n         * Appended to option label e.g. 'Canada selected'\n         */\n        this.srSelectedText = \"selected\";\n        /**\n         * Screen reader explainer added to the list element via aria-label attribute\n         */\n        this.srListLabelText = \"Search suggestions\";\n        /**\n         * Screen reader description announced when the input receives focus.\n         * Only announced when input is empty\n         */\n        this.srAssistiveText = \"When results are available use up and down arrows to review and \" +\n            \"enter to select. Touch device users, explore by touch or with swipe gestures.\";\n        /**\n         * Automatically remove the srAssistiveText once user input is detected,\n         * to reduce screen reader verbosity.\n         * The text is re-associated with the generated input if its value is emptied\n         */\n        this.srAssistiveTextAutoClear = true;\n        /**\n         * Screen reader announcement after results are rendered\n         */\n        this.srResultsText = function (length) {\n            return length + \" \" + (length === 1 ? 'result' : 'results') + \" available.\";\n        };\n        for (var prop in options) {\n            if (options.hasOwnProperty(prop) && typeof options[prop] !== 'undefined') {\n                this[prop] = options[prop];\n            }\n        }\n    }\n    return AutocompleteOptions;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (AutocompleteOptions);\n\n\n//# sourceURL=webpack:///./src/autocomplete-options.ts?");

/***/ }),

/***/ "./src/autocomplete.ts":
/*!*****************************!*\
  !*** ./src/autocomplete.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var is_printable_keycode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-printable-keycode */ \"./node_modules/is-printable-keycode/dist/is-printable-keycode.mjs\");\n/* harmony import */ var input_autowidth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! input-autowidth */ \"./node_modules/input-autowidth/dist/input-autowidth.min.js\");\n/* harmony import */ var input_autowidth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(input_autowidth__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var element_removeclass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! element-removeclass */ \"./node_modules/element-removeclass/dist/element-removeclass.mjs\");\n/* harmony import */ var element_addclass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! element-addclass */ \"./node_modules/element-addclass/dist/element-addclass.mjs\");\n/* harmony import */ var _autocomplete_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./autocomplete-options */ \"./src/autocomplete-options.ts\");\n/* harmony import */ var _autocomplete_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./autocomplete-api */ \"./src/autocomplete-api.ts\");\n/* harmony import */ var _autocomplete_ids__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./autocomplete-ids */ \"./src/autocomplete-ids.ts\");\n/* harmony import */ var _closest_polyfill__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./closest-polyfill */ \"./src/closest-polyfill.ts\");\n/* harmony import */ var _closest_polyfill__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_closest_polyfill__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./autocomplete-constants */ \"./src/autocomplete-constants.ts\");\n/* harmony import */ var _autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./autocomplete-helpers */ \"./src/autocomplete-helpers.ts\");\n\n\n\n\n\n\n\n\n\n\nvar Autocomplete = /** @class */ (function () {\n    function Autocomplete(element, options) {\n        // fail silently if no original element provided\n        if (!element) {\n            return;\n        }\n        // get going!\n        this.init(element, options);\n    }\n    /**\n     * trigger callback in component options\n     */\n    Autocomplete.prototype.triggerOptionCallback = function (name, args, context) {\n        if (args === void 0) { args = []; }\n        if (context === void 0) { context = this.api; }\n        if (typeof this.options[name] === 'function') {\n            return this.options[name].apply(context, args);\n        }\n    };\n    /**\n     * show element with CSS only - if none provided, set list state to visible\n     */\n    Autocomplete.prototype.show = function (element) {\n        if (element) {\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, this.cssNameSpace + \"--hide hide hidden\");\n            element.removeAttribute('aria-hidden');\n            element.removeAttribute('hidden');\n            return;\n        }\n        this.input.setAttribute('aria-expanded', 'true');\n        if (this.showAll) {\n            var expanded = (!!this.forceShowAll).toString();\n            this.showAll.setAttribute('aria-expanded', expanded);\n        }\n        if (!this.menuOpen) {\n            this.show(this.list);\n            this.menuOpen = true;\n            this.triggerOptionCallback('onOpen', [this.list]);\n            if (!this.documentClickBound) {\n                this.documentClickBound = true;\n                document.addEventListener('click', this.documentClick);\n            }\n        }\n    };\n    /**\n     * hide element with CSS only - if none provided, set list state to hidden\n     */\n    Autocomplete.prototype.hide = function (element) {\n        if (element) {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element, this.cssNameSpace + \"--hide hide hidden\");\n            element.setAttribute('aria-hidden', 'true');\n            element.setAttribute('hidden', 'hidden');\n            return;\n        }\n        this.currentSelectedIndex = -1;\n        this.input.setAttribute('aria-expanded', 'false');\n        if (this.showAll) {\n            this.showAll.setAttribute('aria-expanded', 'false');\n        }\n        if (this.menuOpen) {\n            this.hide(this.list);\n            this.menuOpen = false;\n            this.triggerOptionCallback('onClose', [this.list]);\n        }\n    };\n    /**\n     * enable autocomplete (e.g. when under maxItems selected)\n     */\n    Autocomplete.prototype.enable = function () {\n        if (this.disabled) {\n            this.disabled = false;\n            this.input.disabled = false;\n            var cssNameSpace = this.cssNameSpace;\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.input, cssNameSpace + \"__input--disabled disabled\");\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.wrapper, cssNameSpace + \"__wrapper--disabled disabled\");\n            if (this.showAll) {\n                this.showAll.setAttribute('tabindex', '0');\n                Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.showAll, cssNameSpace + \"__show-all--disabled disabled\");\n            }\n        }\n        this.enableDeletions();\n    };\n    /**\n     * disable autocomplete (e.g. when maxItems selected)\n     */\n    Autocomplete.prototype.disable = function (disableDeletions) {\n        if (disableDeletions === void 0) { disableDeletions = false; }\n        if (!this.disabled) {\n            this.disabled = true;\n            this.input.disabled = true;\n            var cssNameSpace = this.cssNameSpace;\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.input, cssNameSpace + \"__input--disabled disabled\");\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.wrapper, cssNameSpace + \"__wrapper--disabled disabled\");\n            if (this.showAll) {\n                this.showAll.setAttribute('tabindex', '-1');\n                Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.showAll, cssNameSpace + \"__show-all--disabled disabled\");\n            }\n        }\n        if (disableDeletions) {\n            this.disableDeletions();\n        }\n    };\n    /**\n     * (re-)enable ability to delete multi-select items\n     */\n    Autocomplete.prototype.enableDeletions = function () {\n        if (!this.deletionsDisabled) {\n            return;\n        }\n        this.deletionsDisabled = false;\n        var nameSpace = this.cssNameSpace;\n        Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.wrapper, nameSpace + \"__wrapper--deletions-disabled\");\n        this.getSelectedElems().forEach(function (element) {\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, nameSpace + \"__selected--disabled\");\n            element.setAttribute('tabindex', '0');\n        });\n        if (this.deleteAll) {\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.deleteAll, nameSpace + \"__delete-all--disabled \" + nameSpace + \"__selected--disabled\");\n            this.deleteAll.setAttribute('tabindex', '0');\n        }\n    };\n    /**\n     * disable ability to delete multi-select items\n     */\n    Autocomplete.prototype.disableDeletions = function () {\n        if (this.deletionsDisabled) {\n            return;\n        }\n        this.deletionsDisabled = true;\n        var nameSpace = this.cssNameSpace;\n        Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.wrapper, nameSpace + \"__wrapper--deletions-disabled\");\n        this.getSelectedElems().forEach(function (element) {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element, nameSpace + \"__selected--disabled\");\n            element.setAttribute('tabindex', '-1');\n        });\n        if (this.deleteAll) {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.deleteAll, nameSpace + \"__delete-all--disabled \" + nameSpace + \"__selected--disabled\");\n            this.deleteAll.setAttribute('tabindex', '-1');\n        }\n    };\n    /**\n     * if in autoGrow mode, trigger an input size re-calc\n     */\n    Autocomplete.prototype.triggerAutoGrow = function () {\n        if (this.autoGrow && this.inputAutoWidth && typeof this.inputAutoWidth.trigger === 'function') {\n            this.inputAutoWidth.trigger();\n        }\n    };\n    /**\n     * set input value to specific string, and related component vars\n     */\n    Autocomplete.prototype.setInputValue = function (value, setPollingValue) {\n        if (setPollingValue === void 0) { setPollingValue = false; }\n        this.term = value;\n        if (this.input) {\n            this.input.value = value;\n        }\n        if (setPollingValue) {\n            this.inputPollingValue = value;\n        }\n        this.triggerAutoGrow();\n    };\n    /**\n     * check if value (or current input value) is contained in a selection of options;\n     * checks for exact string match\n     */\n    Autocomplete.prototype.indexOfValueIn = function (options, value, propToCheck) {\n        if (value === void 0) { value = this.input.value; }\n        if (propToCheck === void 0) { propToCheck = 'label'; }\n        if (options.length && (value = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(value).toLowerCase())) {\n            for (var i = 0, l = options.length; i < l; i += 1) {\n                if (Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(options[i][propToCheck]).toLowerCase() === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * empty the screen reader announcement element after a delay\n     */\n    Autocomplete.prototype.clearAnnouncement = function (clearAfter) {\n        var _this = this;\n        clearTimeout(this.clearAnnouncementTimer);\n        this.clearAnnouncementTimer = setTimeout(function () {\n            if (_this.srAnnouncements) {\n                _this.srAnnouncements.textContent = '';\n            }\n        }, clearAfter);\n    };\n    /**\n     * make a screen reader announcement\n     */\n    Autocomplete.prototype.announce = function (text, delay) {\n        var _this = this;\n        if (delay === void 0) { delay = this.options.srDelay; }\n        if (!this.srAnnouncements || !text || typeof text !== 'string') {\n            return;\n        }\n        var setAnnouncementText = function () {\n            _this.srAnnouncements.textContent = text;\n            // clear the announcement\n            var autoClear = _this.options.srAutoClear;\n            if (autoClear === true || (typeof autoClear === 'number' && autoClear > -1)) {\n                _this.clearAnnouncement(typeof autoClear === 'number' ? autoClear : 10000);\n            }\n        };\n        // in immediate case, do not use timer\n        if (delay === 0) {\n            setAnnouncementText();\n            return;\n        }\n        clearTimeout(this.announcementTimer);\n        this.announcementTimer = setTimeout(function () { return setAnnouncementText(); }, delay);\n    };\n    /**\n     * set the aria-describedby attribute on the input\n     */\n    Autocomplete.prototype.setInputDescription = function () {\n        var exists = this.input.getAttribute('aria-describedby');\n        var current = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(exists);\n        var describedBy = current.replace(this.ids.SR_ASSISTANCE, '');\n        if (!this.input.value.length) {\n            describedBy = describedBy + \" \" + this.ids.SR_ASSISTANCE;\n        }\n        // set or remove attribute, but only if necessary\n        if ((describedBy = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(describedBy))) {\n            if (describedBy !== current) {\n                this.input.setAttribute('aria-describedby', describedBy);\n            }\n        }\n        else if (exists) {\n            this.input.removeAttribute('aria-describedby');\n        }\n    };\n    /**\n     * check if element is a selected element in the DOM\n     */\n    Autocomplete.prototype.isSelectedElem = function (element) {\n        var sourceEntry = element && element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]];\n        return !!(this.multiple && typeof sourceEntry === 'object');\n    };\n    /**\n     * get selected items DOM elements\n     */\n    Autocomplete.prototype.getSelectedElems = function () {\n        var result = [];\n        for (var i = 0, l = this.wrapper.childNodes.length; i < l; i += 1) {\n            var node = this.wrapper.childNodes[i];\n            if (node.nodeType === 1 && this.isSelectedElem(node)) {\n                result.push(node);\n            }\n        }\n        return result;\n    };\n    /**\n     * delete all selected items\n     */\n    Autocomplete.prototype.deleteAllSelected = function () {\n        // prevent removing if deletions are disabled\n        if (this.deletionsDisabled) {\n            return;\n        }\n        // cycle through and de-select\n        var i = this.selected.length;\n        while (i--) {\n            var option = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"mergeObjects\"])(this.selected[i]);\n            // set option or checkbox to not be selected\n            Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"setElementState\"])(option.element, false, this);\n            // fire on delete before updating the DOM\n            this.triggerOptionCallback('onDelete', [option]);\n        }\n        // reset selected array\n        // use splice to modify it to maintain API reference\n        this.selected.splice(0);\n        // update original element values based on now selected items\n        this.setSourceElementValues();\n        // re-build the selected items markup\n        this.buildMultiSelected();\n        // update input size in autoGrow mode\n        this.triggerAutoGrow();\n        // use `srDeletedText` option for now for generic `deleted` announcement;\n        // if this causes issues across locales, build up full deleted string\n        // e.g. `deleted option 1, deleted option 2, etc.`\n        this.announce(this.options.srDeletedText, 0);\n    };\n    /**\n     * remove object from selected options array\n     */\n    Autocomplete.prototype.removeEntryFromSelected = function (entry, keepFocus) {\n        if (keepFocus === void 0) { keepFocus = false; }\n        // prevent removing if deletions are disabled\n        if (this.deletionsDisabled) {\n            return;\n        }\n        // check for explicit match first\n        var index = this.selected.indexOf(entry);\n        // if object reference check did not work, do a manual value check\n        if (index === -1) {\n            for (var i = 0, l = this.selected.length; i < l; i += 1) {\n                if (this.selected[i].value === entry.value) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index > -1 && this.selected[index]) {\n            var option = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"mergeObjects\"])(this.selected[index]);\n            var label = option.label;\n            // set option or checkbox to not be selected\n            Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"setElementState\"])(option.element, false, this);\n            // update array\n            this.selected.splice(index, 1);\n            // fire on delete before updating the DOM\n            this.triggerOptionCallback('onDelete', [option]);\n            // update original element values based on now selected items\n            this.setSourceElementValues();\n            // re-build the selected items markup\n            this.buildMultiSelected(keepFocus ? index : null);\n            // update input size in autoGrow mode\n            this.triggerAutoGrow();\n            // make sure to announce deletion to screen reader users\n            this.announce(label + \" \" + this.options.srDeletedText, 0);\n        }\n    };\n    /**\n     * create a DOM element for entry in selected array\n     */\n    Autocomplete.prototype.createSelectedElemFrom = function (entry, isDeleteAll) {\n        var label = entry.label;\n        var nameSpace = this.cssNameSpace;\n        var selected = nameSpace + \"__selected\";\n        var span = document.createElement('span');\n        var className = isDeleteAll ? nameSpace + \"__delete-all \" + selected + \" \" + selected + \"--delete-all\" : selected;\n        span.setAttribute('aria-describedby', this.ids.LABEL);\n        span.setAttribute('class', className);\n        span.setAttribute('role', 'button');\n        span.setAttribute('tabindex', '0');\n        span.textContent = label;\n        if (!isDeleteAll) {\n            span.setAttribute('aria-label', this.options.srDeleteText + \" \" + label);\n            span[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]] = entry;\n        }\n        return span;\n    };\n    /**\n     * re-build the html showing the selected items\n     * note: there are a lot of loops here - could affect performance\n     */\n    Autocomplete.prototype.buildMultiSelected = function (focusIndex) {\n        var _this = this;\n        // only do anything in multiple mode\n        if (!this.multiple) {\n            return;\n        }\n        // disable or enable as needed\n        if (this.multiple && this.selected.length >= this.options.maxItems) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n        // no elements, and none selected, do nothing\n        var currentSelectedDomElems = this.getSelectedElems();\n        if (!this.selected.length && !currentSelectedDomElems.length) {\n            return;\n        }\n        // cycle through existing DOM elements, and remove any not in the selected array\n        // build up a new array of elements\n        var updatedSelectedDomElems = [];\n        currentSelectedDomElems.forEach(function (element) {\n            var sourceEntry = element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]];\n            // check current dom element against selected array\n            for (var i = 0, l = _this.selected.length; i < l; i += 1) {\n                var selected = _this.selected[i];\n                // if match found, push to new array\n                if (selected === sourceEntry || selected.value === sourceEntry.value) {\n                    updatedSelectedDomElems.push(element);\n                    return;\n                }\n            }\n            // if no match was found, remove from the dom\n            element.parentNode.removeChild(element);\n        });\n        // cycle through selected array, and add elements for each to the DOM\n        var fragment = document.createDocumentFragment();\n        this.selected.forEach(function (selected) {\n            // check if there is an element in the DOM for it already\n            // note: assumes all entries have unique values, but could be an issue\n            // if source is driven by multiple different checkbox groups\n            for (var i = 0, l = updatedSelectedDomElems.length; i < l; i += 1) {\n                var sourceEntry = updatedSelectedDomElems[i][_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]];\n                if (sourceEntry === selected || sourceEntry.value === selected.value) {\n                    return;\n                }\n            }\n            // if there wasn't, add one\n            fragment.appendChild(_this.createSelectedElemFrom(selected));\n        });\n        // insert new elements\n        // can't check against fragment.children or fragment.childElementCount, as does not work in IE\n        if (fragment.childNodes && fragment.childNodes.length) {\n            this.wrapper.insertBefore(fragment, this.srAssistance);\n        }\n        // set ids on selected DOM elements\n        var selectedElems = this.getSelectedElems();\n        var ids = selectedElems.map(function (element, index) {\n            var id = _this.ids.OPTION_SELECTED + \"-\" + index;\n            element.setAttribute('id', id);\n            return id;\n        });\n        ids.push(this.ids.LIST);\n        // indicate to screen readers that the input owns selected elements, and the list\n        this.input.setAttribute('aria-owns', ids.join(' '));\n        // in autoGrow mode, hide the placeholder if there are selected items\n        if (this.autoGrow && this.selected.length) {\n            this.input.removeAttribute('placeholder');\n        }\n        else if (this.options.placeholder) {\n            this.input.setAttribute('placeholder', this.options.placeholder);\n        }\n        // remove delete all control if only 1 selected item (or none)\n        if (this.selected.length <= 1) {\n            if (this.deleteAll) {\n                this.deleteAll.parentNode.removeChild(this.deleteAll);\n                this.deleteAll = null;\n            }\n        }\n        // add the delete all control\n        else if (this.options.deleteAllControl && !this.deleteAll && selectedElems[0]) {\n            this.deleteAll = this.createSelectedElemFrom({ label: this.options.deleteAllText }, true);\n            selectedElems[0].parentNode.insertBefore(this.deleteAll, selectedElems[0]);\n        }\n        // focus specified selected element (e.g. move to next element when deleting one)\n        if (typeof focusIndex === 'number') {\n            // focus specified index if possible\n            // otherwise, check for an element before it, or for the first/any selected elem\n            var toFocus = selectedElems[focusIndex] || selectedElems[focusIndex - 1] || selectedElems[0];\n            if (toFocus && typeof toFocus.focus === 'function') {\n                toFocus.focus();\n            }\n        }\n    };\n    /**\n     * reset classes and aria-selected attribute for all visible filtered options\n     */\n    Autocomplete.prototype.resetOptionAttributes = function (options) {\n        if (options === void 0) { options = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"getChildrenOf\"])(this.list); }\n        var classToRemove = this.cssNameSpace + \"__option--focused focused focus\";\n        options.forEach(function (option) {\n            // omit the aria-selected attribute from non-selectable options\n            if (option.getAttribute('aria-disabled') !== 'true') {\n                option.setAttribute('aria-selected', 'false');\n            }\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(option, classToRemove);\n        });\n    };\n    /**\n     * move focus to correct option, or to input (on up and down arrows)\n     */\n    Autocomplete.prototype.setOptionFocus = function (event, index, triggerDomFocus) {\n        if (triggerDomFocus === void 0) { triggerDomFocus = true; }\n        var options = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"getChildrenOf\"])(this.list);\n        // set aria-selected to false and remove focused class\n        this.resetOptionAttributes(options);\n        // if negative index, or no options available, focus on input\n        if (index < 0 || !options.length) {\n            this.currentSelectedIndex = -1;\n            // focus on input, only if event was from another element\n            if (event && event.target !== this.input) {\n                this.input.focus();\n            }\n            return;\n        }\n        // down arrow on/past last option, focus on last item\n        if (index >= options.length) {\n            this.currentSelectedIndex = options.length - 1;\n            this.setOptionFocus(event, this.currentSelectedIndex);\n            return;\n        }\n        // if option found, move focus to it...\n        var toFocus = options[index];\n        if (toFocus && typeof toFocus.getAttribute('tabindex') === 'string') {\n            this.currentSelectedIndex = index;\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(toFocus, this.cssNameSpace + \"__option--focused focused focus\");\n            // omit the aria-selected attribute from non-selectable options\n            if (toFocus.getAttribute('aria-disabled') !== 'true') {\n                toFocus.setAttribute('aria-selected', 'true');\n            }\n            if (triggerDomFocus) {\n                toFocus.focus();\n            }\n            return;\n        }\n        // reset index just in case none of the above conditions are met\n        this.currentSelectedIndex = -1;\n    };\n    /**\n     * set values and dispatch events based on any DOM elements in the selected array\n     */\n    Autocomplete.prototype.setSourceElementValues = function () {\n        var valToSet = [];\n        for (var i = 0, l = this.selected.length; i < l; i += 1) {\n            var entry = this.selected[i];\n            valToSet.push(entry.value);\n            Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"setElementState\"])(entry.element, true, this); // element processing\n        }\n        // set original input value\n        if (this.elementIsInput) {\n            var valToSetString = valToSet.join(this.options.multipleSeparator);\n            // only set and trigger change if value will be different\n            if (valToSetString !== this.element.value) {\n                this.element.value = valToSetString;\n                Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"dispatchEvent\"])(this.element, 'change');\n            }\n        }\n        // included in case of multi-select mode used with a <select> element as the source\n        if (!this.selected.length && this.sourceFromSelect) {\n            this.element.value = '';\n        }\n        this.triggerOptionCallback('onChange', [this.selected]);\n    };\n    /**\n     * select option from the list by index\n     */\n    Autocomplete.prototype.handleOptionSelect = function (event, index, focusInputAfterSelection) {\n        if (focusInputAfterSelection === void 0) { focusInputAfterSelection = true; }\n        // defensive check for proper index, that the filteredSource exists, and not exceed max items option\n        if (typeof index !== 'number' ||\n            index < 0 ||\n            (this.multiple && this.selected.length >= this.options.maxItems) ||\n            !this.filteredSource.length ||\n            !this.filteredSource[index]) {\n            return;\n        }\n        // generate new object from the selected item in case the original source gets altered\n        var option = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"mergeObjects\"])(this.filteredSource[index]);\n        // check if option or linked element is disabled\n        if (option.disabled || (option.element && option.element.disabled)) {\n            return;\n        }\n        // detect if selected option is already in selected array\n        var alreadySelected = false;\n        for (var i = 0, l = this.selected.length; i < l; i += 1) {\n            if (this.selected[i].value === option.value) {\n                alreadySelected = true;\n                break;\n            }\n        }\n        // reset selected array in single select mode\n        // use splice so that selected Array in API is also correctly updated\n        if (!alreadySelected && !this.multiple) {\n            this.selected.splice(0);\n        }\n        // (re)set values of any DOM elements based on selected array\n        if (!alreadySelected) {\n            // add entry to the DOM if necessary\n            this.addResultsEntryToDomAndSource(option);\n            this.selected.push(option);\n            this.setSourceElementValues();\n            // rebuild multi-selected if needed\n            this.buildMultiSelected();\n        }\n        // update the visible input - empty it if in multiple mode\n        // do this after multiSelected elements are built,\n        // in case placeholder is affected in autoGrow mode\n        this.setInputValue(this.multiple ? '' : option.label, true);\n        // trigger callback and announce selection to screen reader users\n        this.triggerOptionCallback('onConfirm', [option]);\n        this.announce(option.label + \" \" + this.options.srSelectedText, 0);\n        // return focus to input\n        if (!this.disabled && focusInputAfterSelection !== false && this.input) {\n            this.input.focus();\n        }\n        // close menu after option selection, and after returning focus to input\n        this.hide();\n    };\n    /**\n     * remove selected entries from list results if in multiple mode\n     */\n    Autocomplete.prototype.removeSelectedFromResults = function (results) {\n        var _this = this;\n        if (!this.multiple || !this.selected.length) {\n            return results;\n        }\n        var toReturn = [];\n        results.forEach(function (entry) {\n            var selected = _this.selected;\n            for (var i = 0, l = selected.length; i < l; i += 1) {\n                // check for label and value match\n                if (entry.label === selected[i].label && entry.value === selected[i].value) {\n                    return;\n                }\n            }\n            toReturn.push(entry);\n        });\n        return toReturn;\n    };\n    /**\n     * in create mode, if source options were from a dropdown or checkboxlist,\n     * append the chosen option at list start and update internal source\n     * @todo: confirm performance and cloned result is as expected in IE9+\n     */\n    Autocomplete.prototype.addResultsEntryToDomAndSource = function (option) {\n        var create = this.options.create;\n        var _a = this, sourceFromSelect = _a.sourceFromSelect, sourceFromCheckboxList = _a.sourceFromCheckboxList;\n        // only applies to create mode, and if the option has a value;\n        // limit this method to only affect dropdown and checkbox list sources;\n        // if the source is not an array, we can't update it or the DOM;\n        if (!create ||\n            !option ||\n            !option.value ||\n            !Array.isArray(this.source) ||\n            !(sourceFromSelect || sourceFromCheckboxList)) {\n            return;\n        }\n        // if a matching source entry already exists, it does not need to be added;\n        // use this check to assume a matching element already exists in the DOM as well for performance\n        // so that we don't need to do any DOM interrogation\n        var label = option.label, value = option.value;\n        if (this.indexOfValueIn(this.source, value, 'value') > -1 ||\n            this.indexOfValueIn(this.source, label, 'label') > -1) {\n            return;\n        }\n        var element;\n        // dropdown list case\n        if (sourceFromSelect) {\n            var existingOption = this.element.querySelector('option');\n            var newOption = existingOption.cloneNode(true);\n            newOption.textContent = label;\n            newOption.value = value;\n            element = newOption;\n            // insert the new option at the beginning of the list\n            existingOption.parentNode.insertBefore(newOption, existingOption);\n        }\n        // checkboxlist case\n        else if (sourceFromCheckboxList) {\n            var existingCheckbox = this.element.querySelector('input[type=\"checkbox\"]');\n            var newCheckbox = existingCheckbox.cloneNode(true);\n            var existingLabel = existingCheckbox.closest('label');\n            var newLabel = document.createElement('label');\n            newLabel.textContent = label;\n            newCheckbox.value = value;\n            element = newCheckbox;\n            // if the detected existing checkbox in the list had a label parent,\n            // insert the new label as a sibling, otherwise just insert next to checkbox\n            newLabel.appendChild(newCheckbox);\n            var insertNextTo = existingLabel || existingCheckbox;\n            insertNextTo.parentNode.insertBefore(newLabel, insertNextTo);\n        }\n        // add the element to the option so that it is correctly updated\n        // within the `setSourceElementValues` method\n        if (element) {\n            option.element = element;\n            // for safety, remove the cloned element id to prevent duplicates\n            element.removeAttribute('id');\n        }\n        // update the `source` array so that the option will be available again\n        // if it's deleted from the selected list;\n        // place at the beginning to take precedence over existing options\n        this.source.unshift(option);\n    };\n    /**\n     * when `create` option is true, or a function that returns a value,\n     * add an entry to the `results` for the specified search term;\n     * modifies the provided `results` array\n     */\n    Autocomplete.prototype.prependEntryInCreateMode = function (fromTerm, results) {\n        var create = this.options.create;\n        // if the option is falsy or not a function, or the search value is empty, do nothing\n        if (!(create === true || typeof create === 'function') || !Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"cleanString\"])(fromTerm)) {\n            return;\n        }\n        var entryToAdd;\n        var trimmedTerm = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(fromTerm);\n        var mapping = this.options.sourceMapping;\n        // simple entry creation when set to true, based on the trimmed value (not cleaned value)\n        if (create === true) {\n            entryToAdd = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceEntry\"])(trimmedTerm, mapping);\n        }\n        // when function, check the result first...\n        if (typeof create === 'function') {\n            var result = this.triggerOptionCallback('create', [trimmedTerm]);\n            var resultType = typeof result;\n            // check that the result was a string or object\n            // if devs want to add multiple entries, they can use the `onResponse` callback\n            if (result && (resultType === 'string' || (resultType === 'object' && !Array.isArray(result)))) {\n                entryToAdd = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceEntry\"])(result, mapping);\n            }\n        }\n        // only add it if there's actually something to add\n        if (!entryToAdd ||\n            !entryToAdd.label ||\n            !entryToAdd.value ||\n            // if there's an exact label match in the results, give original entry precedence\n            this.indexOfValueIn(results, entryToAdd[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"CLEANED_LABEL_PROP\"]], _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"CLEANED_LABEL_PROP\"]) > -1 ||\n            // also keep unique values in the results\n            this.indexOfValueIn(results, entryToAdd.value, 'value') > -1) {\n            return;\n        }\n        // finally, add the entry by modifying the original array\n        results.unshift(entryToAdd);\n    };\n    /**\n     * final filtering and render for list options\n     */\n    Autocomplete.prototype.setListOptions = function (results) {\n        var mapping = this.options.sourceMapping;\n        this.prependEntryInCreateMode(this.term, results);\n        // if in multiple mode, exclude items already in the selected array\n        var updated = this.removeSelectedFromResults(results);\n        // allow callback to alter the response before rendering;\n        // only provide a shallow copy of the source so that the callback cannot modify it\n        var callback = this.triggerOptionCallback('onResponse', [updated.slice()]);\n        // at last, set the fully filtered source\n        this.filteredSource = Array.isArray(callback) ? Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceArray\"])(callback, mapping) : updated;\n        // build up the list html\n        var optionId = this.ids.OPTION;\n        var cssNameSpace = this.cssNameSpace;\n        var optionClassName = cssNameSpace + \"__option\";\n        var length = this.filteredSource.length;\n        var checkCallback = typeof this.options.onItemRender === 'function';\n        var maxResults = this.forceShowAll ? 9999 : this.options.maxResults;\n        var lengthToUse = maxResults < length ? maxResults : length;\n        var toShow = [];\n        for (var i = 0; i < lengthToUse; i += 1) {\n            var entry = this.filteredSource[i];\n            var callbackResponse = checkCallback && this.triggerOptionCallback('onItemRender', [entry]);\n            var itemContent = typeof callbackResponse === 'string' ? callbackResponse : entry.label;\n            var disabled = !!(entry.disabled || (entry.element && entry.element.disabled));\n            // omit the aria-selected attribute from non-selectable options\n            var ariaSelected = !disabled ? ' aria-selected=\"false\"' : '';\n            toShow.push(\"<li tabindex=\\\"-1\\\"\" + ariaSelected + \" role=\\\"option\\\" class=\\\"\" + optionClassName + \"\\\" \" +\n                (\"aria-disabled=\\\"\" + disabled + \"\\\" id=\\\"\" + optionId + \"--\" + i + \"\\\" aria-posinset=\\\"\" + (i + 1) + \"\\\" \") +\n                (\"aria-setsize=\\\"\" + lengthToUse + \"\\\">\" + Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"escapeHtml\"])(itemContent) + \"</li>\"));\n        }\n        var noResults = !toShow.length;\n        // set has-results or no-results class on the list element\n        if (noResults) {\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.list, cssNameSpace + \"__list--has-results\");\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.list, cssNameSpace + \"__list--no-results\");\n        }\n        else {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.list, cssNameSpace + \"__list--has-results\");\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.list, cssNameSpace + \"__list--no-results\");\n        }\n        // no results text handling\n        var announce;\n        var noText = this.options.noResultsText;\n        if (noResults && typeof noText === 'string' && noText.length) {\n            announce = noText;\n            toShow.push(\"<li class=\\\"\" + optionClassName + \" \" + optionClassName + \"--no-results\\\">\" + Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"escapeHtml\"])(noText) + \"</li>\");\n        }\n        // remove loading class(es) and reset variables\n        this.cancelFilterPrep();\n        // announce to screen reader\n        if (!announce) {\n            announce = this.triggerOptionCallback('srResultsText', [lengthToUse]);\n        }\n        if (announce) {\n            this.announce(announce);\n        }\n        // render the list, only if we have to\n        // time taken for string comparison is worth it to not have to re-parse and re-render the list\n        var newListHtml = toShow.join('');\n        if (this.currentListHtml !== newListHtml) {\n            this.currentListHtml = newListHtml;\n            // innerHTML vs insertAdjacentHtml performance in old IE ?\n            this.list.innerHTML = newListHtml;\n        }\n        else {\n            // if list html matches, and not re-rendered, clear aria-selected and focus classes\n            this.resetOptionAttributes();\n        }\n        // if `toShow` array is empty, make sure not to render the menu\n        // must check `toShow` length in case a \"no results\" entry was added\n        if (!toShow.length) {\n            this.hide();\n            this.forceShowAll = false;\n            return;\n        }\n        this.show();\n        // reset forceShowAll must be after .show()\n        // aria-expanded attribute on showAllControl is set in .show() method\n        this.forceShowAll = false;\n    };\n    /**\n     * trigger async call for options to render\n     */\n    Autocomplete.prototype.handleAsync = function (value, isFirstCall) {\n        var _this = this;\n        if (isFirstCall === void 0) { isFirstCall = false; }\n        // abort any current call first\n        if (this.xhr && typeof this.xhr.abort === 'function') {\n            this.xhr.abort();\n        }\n        var xhr = new XMLHttpRequest();\n        var isShowAll = this.forceShowAll;\n        var context = isFirstCall ? null : this.api;\n        var baseAmount = this.multiple ? this.selected.length : 0;\n        var unlimited = isShowAll || isFirstCall || this.options.maxResults === 9999;\n        var url = this.source +\n            (/\\?/.test(this.source) ? '&' : '?') +\n            (encodeURIComponent(this.options.asyncQueryParam) + \"=\" + encodeURIComponent(value) + \"&\") +\n            (encodeURIComponent(this.options.asyncMaxResultsParam) + \"=\") +\n            (\"\" + (unlimited ? 9999 : baseAmount + this.options.maxResults));\n        // allow url modification via the onAsyncPrep callback\n        var prepUrl = this.triggerOptionCallback('onAsyncPrep', [url, xhr, isFirstCall], context);\n        if (prepUrl && typeof prepUrl === 'string') {\n            url = prepUrl;\n        }\n        xhr.open('GET', url);\n        xhr.onload = function () {\n            if (xhr.readyState !== xhr.DONE) {\n                return;\n            }\n            if (xhr.status >= 200 && xhr.status < 300) {\n                // return forceShowAll to previous state before the options render\n                _this.forceShowAll = isShowAll;\n                var response = _this.triggerOptionCallback('onAsyncSuccess', [value, xhr, isFirstCall], context);\n                var source = response || xhr.responseText;\n                var items = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceArray\"])(source, _this.options.sourceMapping);\n                if (isFirstCall) {\n                    _this.prepSelectedFromArray(items);\n                    _this.setInputStartingStates(false);\n                }\n                else {\n                    _this.setListOptions(items);\n                }\n                _this.triggerOptionCallback('onAsyncComplete', [value, xhr, isFirstCall], context);\n            }\n        };\n        xhr.onerror = function () {\n            _this.triggerOptionCallback('onAsyncError', [value, xhr, isFirstCall], context);\n        };\n        // allow the creation of an uncancellable call to use on first load\n        if (!isFirstCall) {\n            this.xhr = xhr;\n        }\n        // before send option callback, to allow adjustments to the xhr object,\n        // e.g. adding auth headers\n        this.triggerOptionCallback('onAsyncBeforeSend', [value, xhr, isFirstCall], context);\n        xhr.send();\n    };\n    /**\n     * trigger filtering using a value\n     */\n    Autocomplete.prototype.filter = function (value) {\n        var _this = this;\n        // fail silently if no value is provided\n        if (typeof value !== 'string') {\n            this.cancelFilterPrep();\n            return;\n        }\n        // allow onSearch callback to affect the search value\n        // only permitted when not a forceShowAll case\n        var forceShowAll = this.forceShowAll;\n        if (!forceShowAll) {\n            var callbackResponse = this.triggerOptionCallback('onSearch', [value]);\n            if (typeof callbackResponse === 'string') {\n                value = callbackResponse;\n            }\n        }\n        // store search term - used for comparison in filterPrep\n        this.term = value;\n        // async handling\n        if (typeof this.source === 'string' && this.source.length) {\n            this.handleAsync(value);\n            // set show all to false immediately as may be used in other places\n            this.forceShowAll = false;\n            return;\n        }\n        // handle the source as a function\n        if (typeof this.source === 'function') {\n            // provide a render function to use as a callback\n            var render_1 = function (toRender) {\n                var result = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceArray\"])(toRender, _this.options.sourceMapping);\n                _this.setListOptions(result);\n            };\n            // check for `then` function on the result to allow use of a promise\n            var result = this.source.call(this.api, this.term, render_1, false);\n            if (result && typeof result.then === 'function') {\n                result.then(function (toRender) { return render_1(toRender); });\n            }\n            return;\n        }\n        // if empty string, show all\n        if (!value) {\n            forceShowAll = true;\n        }\n        // build up results from static list\n        var toReturn = [];\n        var source = this.source;\n        if (source && source.length) {\n            // build up array of source entry props to search in\n            var toCheck_1 = [_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"CLEANED_LABEL_PROP\"]];\n            if (!forceShowAll) {\n                value = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"cleanString\"])(value, true);\n                var searchIn = this.options.alsoSearchIn;\n                if (Array.isArray(searchIn) && searchIn.length) {\n                    toCheck_1 = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"prepSearchInArray\"])(toCheck_1.concat(searchIn));\n                }\n            }\n            // include everything in forceShowAll case\n            source.forEach(function (entry) {\n                if (forceShowAll || Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"searchSourceEntryFor\"])(entry, value, toCheck_1)) {\n                    toReturn.push(entry);\n                }\n            });\n        }\n        // now render!\n        this.setListOptions(toReturn);\n    };\n    /**\n     * cancel filter timer and remove loading classes\n     */\n    Autocomplete.prototype.cancelFilterPrep = function () {\n        clearTimeout(this.filterTimer);\n        Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.wrapper, this.cssNameSpace + \"__wrapper--loading loading\");\n        Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.input, this.cssNameSpace + \"__input--loading loading\");\n        this.filtering = false;\n    };\n    /**\n     * prepare to run filter - pre checks, and timer\n     */\n    Autocomplete.prototype.filterPrep = function (event, doValueOverrideCheck, runNow) {\n        var _this = this;\n        if (doValueOverrideCheck === void 0) { doValueOverrideCheck = false; }\n        if (runNow === void 0) { runNow = false; }\n        var forceShowAll = this.forceShowAll;\n        var delay = forceShowAll || runNow ? 0 : this.options.delay;\n        // clear timers and set internal state\n        this.cancelFilterPrep();\n        this.filtering = true;\n        this.filterTimer = setTimeout(function () {\n            var value = _this.input.value;\n            // set polling value, even if search criteria are not met\n            _this.inputPollingValue = value;\n            // treat as empty search if:\n            // forceShowAll, or in single mode and selected item label matches current value\n            if (forceShowAll ||\n                value === '' ||\n                (doValueOverrideCheck &&\n                    !_this.multiple &&\n                    _this.selected.length &&\n                    Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(_this.selected[0].label) === Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"trimString\"])(value))) {\n                value = '';\n            }\n            // handle aria-describedby updates\n            if (event && event.type && _this.options.srAssistiveTextAutoClear) {\n                _this.setInputDescription();\n            }\n            // length check\n            if (!forceShowAll && value.length < _this.options.minLength) {\n                _this.hide();\n                return;\n            }\n            // try catch used due to permissions issues in some cases\n            var modifier;\n            try {\n                var keyEvent = event;\n                var isKeydown = event && event.type === 'keydown';\n                // allow shift key, just in case...\n                modifier = isKeydown && (keyEvent.altKey || keyEvent.ctrlKey || keyEvent.metaKey);\n            }\n            catch (e) { }\n            // prevent search being run again with the same value\n            var equalVals = value === '' ? false : value === _this.term;\n            if (!equalVals || (equalVals && !_this.menuOpen && !modifier)) {\n                Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_this.wrapper, _this.cssNameSpace + \"__wrapper--loading loading\");\n                Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_this.input, _this.cssNameSpace + \"__input--loading loading\");\n                _this.currentSelectedIndex = -1;\n                _this.filter(value);\n            }\n            else {\n                // if search wasn't run, make sure to clear internal state,\n                // otherwise it will block the down key from moving to the options;\n                // thanks to /u/holloway on reddit for discovering this\n                _this.cancelFilterPrep();\n            }\n        }, delay);\n    };\n    /**\n     * trigger filter prep in showAll mode\n     */\n    Autocomplete.prototype.filterPrepShowAll = function (event) {\n        var _this = this;\n        if (this.disabled) {\n            return;\n        }\n        // need to use a timer so that this is triggered after the wrapper focusout\n        clearTimeout(this.showAllPrepTimer);\n        this.showAllPrepTimer = setTimeout(function () {\n            if (_this.componentBlurTimer) {\n                clearTimeout(_this.componentBlurTimer);\n            }\n            event.preventDefault();\n            _this.forceShowAll = true;\n            _this.filterPrep(event, false, true);\n        }, 0);\n    };\n    /**\n     * blur behaviour for hiding list and removing focus class(es)\n     * forced when using escape key\n     */\n    Autocomplete.prototype.handleComponentBlur = function (event, force) {\n        var _this = this;\n        if (force === void 0) { force = false; }\n        clearTimeout(this.componentBlurTimer);\n        // use a timeout to ensure this blur fires after other focus events\n        // and in case the user focuses back in immediately\n        var delay = force ? 0 : 100;\n        this.componentBlurTimer = setTimeout(function () {\n            // do nothing if blurring to an element within the list\n            var activeElem = document.activeElement;\n            if (!force &&\n                activeElem &&\n                // exception for delete all button\n                !(_this.deleteAll && _this.deleteAll === activeElem) &&\n                // exception for selected items, as these sit below the input by default\n                !_this.isSelectedElem(activeElem) &&\n                // must base this on the wrapper to allow scrolling the list in IE\n                _this.wrapper.contains(activeElem)) {\n                return;\n            }\n            // cancel any running async call\n            if (_this.xhr && typeof _this.xhr.abort === 'function') {\n                _this.xhr.abort();\n            }\n            // confirmOnBlur behaviour\n            if (!force && _this.options.confirmOnBlur && _this.menuOpen) {\n                // if blurring from an option (currentSelectedIndex > -1), select it\n                var toUse = _this.currentSelectedIndex;\n                if (typeof toUse !== 'number' || toUse === -1) {\n                    // otherwise check for exact match of cleaned values\n                    // between current input value and available items\n                    var copiedSource = _this.filteredSource.slice();\n                    var onConfirmVal = _this.triggerOptionCallback('confirmOnBlur', [_this.term, copiedSource]);\n                    var useOnConfirmVal = onConfirmVal && typeof onConfirmVal === 'string';\n                    var cleanedTerm = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"cleanString\"])(useOnConfirmVal ? onConfirmVal : _this.term);\n                    toUse = _this.indexOfValueIn.call(_this, _this.filteredSource, cleanedTerm, _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"CLEANED_LABEL_PROP\"]);\n                }\n                _this.handleOptionSelect({}, toUse, false);\n            }\n            // cancel timers and hide menu\n            _this.cancelFilterPrep();\n            _this.hide();\n            // in single select case, if current value and chosen value differ, clear selected and input value\n            if (!_this.multiple && _this.indexOfValueIn.call(_this, _this.selected) === -1) {\n                if (_this.selected.length) {\n                    _this.removeEntryFromSelected(_this.selected[0]);\n                }\n                var inputOrDdl = _this.elementIsInput || _this.sourceFromSelect;\n                var originalElement = _this.element;\n                if (inputOrDdl && originalElement.value !== '') {\n                    originalElement.value = '';\n                    Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"dispatchEvent\"])(originalElement, 'change');\n                }\n                _this.setInputValue('', true);\n            }\n            // always clear input value in multiple mode\n            if (_this.multiple) {\n                _this.setInputValue('', true);\n            }\n            // unbind document click\n            if (_this.documentClickBound) {\n                _this.documentClickBound = false;\n                document.removeEventListener('click', _this.documentClick);\n            }\n            _this.triggerOptionCallback('onBlur', [_this.wrapper]);\n            _this.isFocused = false;\n        }, delay);\n    };\n    /**\n     * up arrow usage within the component; for option focus, or return focus to input\n     */\n    Autocomplete.prototype.handleUpKey = function (event) {\n        event.preventDefault();\n        if (!this.disabled && this.menuOpen && typeof this.currentSelectedIndex === 'number') {\n            this.setOptionFocus(event, this.currentSelectedIndex - 1);\n        }\n    };\n    /**\n     * down arrow usage within the component; for option focus, or showAll\n     */\n    Autocomplete.prototype.handleDownKey = function (event) {\n        event.preventDefault();\n        // if closed, and text is long enough, run search\n        if (!this.menuOpen) {\n            var minLength = this.options.minLength;\n            this.forceShowAll = minLength < 1;\n            if (this.forceShowAll || this.input.value.length >= minLength) {\n                this.filterPrep(event);\n            }\n        }\n        // if menu is open and a search is not running, move focus to downward option\n        if (this.menuOpen && !this.filtering) {\n            var current = this.currentSelectedIndex;\n            if (typeof current !== 'number' || current < 0) {\n                this.setOptionFocus(event, 0);\n            }\n            else {\n                this.setOptionFocus(event, current + 1);\n            }\n        }\n    };\n    /**\n     * end key handling within the component; move focus to last option\n     */\n    Autocomplete.prototype.handleEndKey = function (event) {\n        if (!this.disabled && this.menuOpen && event.target !== this.input) {\n            var options = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"getChildrenOf\"])(this.list);\n            if (options.length) {\n                event.preventDefault();\n                this.setOptionFocus(event, options.length - 1);\n            }\n        }\n    };\n    /**\n     * home key handling within the component; move focus to first option\n     */\n    Autocomplete.prototype.handleHomeKey = function (event) {\n        if (!this.disabled && this.menuOpen && event.target !== this.input) {\n            event.preventDefault();\n            this.setOptionFocus(event, 0);\n        }\n    };\n    /**\n     * page up key handling within the component; move focus up by 10\n     */\n    Autocomplete.prototype.handlePageUpKey = function (event) {\n        if (!this.disabled && this.menuOpen && event.target !== this.input) {\n            event.preventDefault();\n            var current = this.currentSelectedIndex;\n            var index = current > 0 && current - 10 < 0 ? 0 : current === 0 ? -1 : current - 10;\n            this.setOptionFocus(event, index);\n        }\n    };\n    /**\n     * page down key handling within the component; move down by 10\n     */\n    Autocomplete.prototype.handlePageDownKey = function (event) {\n        if (!this.disabled && this.menuOpen && event.target !== this.input) {\n            event.preventDefault();\n            var current = this.currentSelectedIndex;\n            this.setOptionFocus(event, current < 0 ? 0 : current + 10);\n        }\n    };\n    /**\n     * enter keydown anywhere within the component\n     */\n    Autocomplete.prototype.handleEnterKey = function (event) {\n        var target = event.target;\n        // if in multiple mode, and event target was a selected item, remove it;\n        // this needs to be possible even when the autocomplete is disabled\n        if (this.isSelectedElem(target)) {\n            this.removeEntryFromSelected(target[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]], true);\n            return;\n        }\n        if (this.deleteAll && target === this.deleteAll) {\n            this.deleteAllSelected();\n            return;\n        }\n        if (this.disabled) {\n            return;\n        }\n        if (this.showAll && target === this.showAll) {\n            this.filterPrepShowAll(event);\n            return;\n        }\n        if (this.menuOpen) {\n            event.preventDefault();\n            if (this.currentSelectedIndex > -1) {\n                this.handleOptionSelect(event, this.currentSelectedIndex);\n            }\n        }\n        // if enter keypress was from the filter input, trigger search immediately\n        if (target === this.input) {\n            this.filterPrep(event, false, true);\n        }\n    };\n    /**\n     * all other keydown handling within the component;\n     * enter, up, down, home, end, and escape handled elsewhere\n     */\n    Autocomplete.prototype.handleKeyDownDefault = function (event) {\n        var keycode = event.keyCode;\n        var targetIsInput = event.target === this.input;\n        // on space, if focus state is on any other item than the input, treat as enter;\n        // on delete on a selected elem, treat as enter to delete it\n        if ((keycode === _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].SPACE && !targetIsInput) ||\n            (this.isSelectedElem(event.target) && keycode === _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].DELETE)) {\n            event.preventDefault();\n            this.handleEnterKey(event);\n            return;\n        }\n        if (this.disabled) {\n            return;\n        }\n        // on backspace, if using empty input in multiple mode, delete last selected entry\n        var selectedLength = this.selected && this.selected.length;\n        if (this.options.deleteOnBackspace &&\n            keycode === _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].BACKSPACE &&\n            this.input.value === '' &&\n            selectedLength &&\n            targetIsInput &&\n            this.multiple) {\n            this.removeEntryFromSelected(this.selected[selectedLength - 1]);\n            // do not return here, to allow the search results to update\n        }\n        // any printable character not on input, return focus to input\n        var printableKey = Object(is_printable_keycode__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(keycode);\n        var focusInput = !targetIsInput && printableKey;\n        if (focusInput) {\n            this.input.focus();\n        }\n        // trigger filtering - done here, instead of using input event, due to IE9 issues\n        if (focusInput || (targetIsInput && printableKey)) {\n            this.filterPrep(event);\n        }\n    };\n    /**\n     * component keydown handling\n     */\n    Autocomplete.prototype.prepKeyDown = function (event) {\n        switch (event.keyCode) {\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].UP:\n                this.handleUpKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].DOWN:\n                this.handleDownKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].END:\n                this.handleEndKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].HOME:\n                this.handleHomeKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].ENTER:\n                this.handleEnterKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].PAGEUP:\n                this.handlePageUpKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].PAGEDOWN:\n                this.handlePageDownKey(event);\n                break;\n            case _autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"KEYCODES\"].ESCAPE:\n                this.handleComponentBlur(event, true);\n                break;\n            default:\n                this.handleKeyDownDefault(event);\n                break;\n        }\n    };\n    /**\n     * cancel checking for input value changes from external causes\n     */\n    Autocomplete.prototype.cancelPolling = function () {\n        clearTimeout(this.pollingTimer);\n    };\n    /**\n     * start checking for input value changes from causes that bypass event detection;\n     * e.g. dictation software\n     */\n    Autocomplete.prototype.startPolling = function () {\n        var _this = this;\n        // check if input value does not equal last searched term\n        if (!this.filtering && this.input.value !== this.inputPollingValue) {\n            this.filterPrep({});\n        }\n        this.pollingTimer = setTimeout(function () {\n            _this.startPolling();\n        }, 200);\n    };\n    /**\n     * bind component event listeners to generated elements\n     */\n    Autocomplete.prototype.bindEvents = function () {\n        var _this = this;\n        // when focus is moved outside of the component, close everything\n        this.wrapper.addEventListener('focusout', function (event) {\n            _this.handleComponentBlur(event, false);\n        });\n        // reset selected index\n        this.wrapper.addEventListener('focusin', function (event) {\n            if (!_this.list.contains(event.target)) {\n                _this.currentSelectedIndex = -1;\n            }\n            if (!_this.isFocused) {\n                _this.triggerOptionCallback('onFocus', [_this.wrapper]);\n            }\n            _this.isFocused = true;\n        });\n        // handle all keydown events inside the component\n        this.wrapper.addEventListener('keydown', function (event) {\n            _this.prepKeyDown(event);\n        });\n        // if clicking directly on the wrapper, move focus to the input\n        this.wrapper.addEventListener('click', function (event) {\n            if (event.target === _this.wrapper) {\n                _this.input.focus();\n                return;\n            }\n            if (_this.isSelectedElem(event.target)) {\n                _this.removeEntryFromSelected(event.target[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"SELECTED_OPTION_PROP\"]], true);\n            }\n            if (_this.deleteAll && event.target === _this.deleteAll) {\n                _this.deleteAllSelected();\n            }\n        });\n        var wrapperFocusClasses = this.cssNameSpace + \"__wrapper--focused focused focus\";\n        var inputFocusClasses = this.cssNameSpace + \"__input--focused focused focus\";\n        // when blurring out of input, remove classes\n        this.input.addEventListener('blur', function () {\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_this.wrapper, wrapperFocusClasses);\n            Object(element_removeclass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_this.input, inputFocusClasses);\n            _this.cancelPolling();\n        });\n        // trigger filter on input event as well as keydown (covering bases)\n        this.input.addEventListener('input', function (event) {\n            if (document.activeElement === _this.input) {\n                _this.filterPrep(event);\n            }\n        });\n        // when specifically clicking on input, if menu is closed, and value is long enough, search\n        this.input.addEventListener('click', function (event) {\n            if (!_this.menuOpen && _this.input.value.length >= _this.options.minLength) {\n                _this.filterPrep(event, true);\n            }\n        });\n        // when focusing on input, reset selected index and trigger search handling\n        this.input.addEventListener('focusin', function (event) {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_this.wrapper, wrapperFocusClasses);\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_this.input, inputFocusClasses);\n            _this.startPolling();\n            if (!_this.disabled && !_this.menuOpen) {\n                _this.filterPrep(event, true);\n            }\n        });\n        // show all button click\n        if (this.showAll) {\n            this.showAll.addEventListener('click', function (event) {\n                _this.filterPrepShowAll(event);\n            });\n        }\n        // clear any current focus position when hovering into the list\n        this.list.addEventListener('mouseenter', function (event) {\n            _this.resetOptionAttributes();\n        });\n        // trigger options selection\n        this.list.addEventListener('click', function (event) {\n            if (event.target !== _this.list) {\n                var options = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"getChildrenOf\"])(_this.list);\n                if (options.length) {\n                    var optionIndex = options.indexOf(event.target);\n                    _this.handleOptionSelect(event, optionIndex);\n                }\n            }\n        });\n        // setup input autoGrow behaviour\n        if (this.autoGrow) {\n            this.inputAutoWidth = new input_autowidth__WEBPACK_IMPORTED_MODULE_1___default.a(this.input);\n        }\n    };\n    /**\n     * set starting source array based on child checkboxes\n     */\n    Autocomplete.prototype.prepListSourceCheckboxes = function () {\n        this.multiple = true; // force multiple in this case\n        // reset source and use checkboxes\n        this.source = [];\n        var elements = this.element.querySelectorAll('input[type=\"checkbox\"]');\n        for (var i = 0, l = elements.length; i < l; i += 1) {\n            var checkbox = elements[i];\n            // must have a value other than empty string\n            if (!checkbox.value) {\n                continue;\n            }\n            var entry = { value: checkbox.value };\n            // label searching\n            var checkboxLabelElem = checkbox.closest('label');\n            if (!checkboxLabelElem && checkbox.id) {\n                checkboxLabelElem = document.querySelector('[for=\"' + checkbox.id + '\"]');\n            }\n            if (checkboxLabelElem) {\n                entry.label = checkboxLabelElem.textContent;\n            }\n            // if there was no label, `processSourceEntry` will re-use the value\n            var toPush = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceEntry\"])(entry);\n            toPush.element = checkbox;\n            this.source.push(toPush);\n            // add to selected if applicable\n            if (checkbox.checked) {\n                this.selected.push(toPush);\n            }\n        }\n    };\n    /**\n     * set starting source array based on <select> options\n     */\n    Autocomplete.prototype.prepListSourceDdl = function () {\n        var elementIsMultiple = this.element.multiple;\n        // force multiple if select handles multiple\n        if (elementIsMultiple && !this.multiple) {\n            this.multiple = true;\n        }\n        // if options set to multiple mode, but select does not support it, limit selections to 1\n        if (!elementIsMultiple && this.multiple && this.options.maxItems > 1) {\n            this.options.maxItems = 1;\n        }\n        // reset source and use options\n        this.source = [];\n        var options = this.element.querySelectorAll('option');\n        for (var i = 0, l = options.length; i < l; i += 1) {\n            var option = options[i];\n            // must have a value other than empty string\n            if (!option.value) {\n                continue;\n            }\n            var toPush = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceEntry\"])({ value: option.value, label: option.textContent });\n            toPush.element = option;\n            this.source.push(toPush);\n            // add to selected if applicable\n            if (option.selected) {\n                this.selected.push(toPush);\n            }\n        }\n    };\n    /**\n     * build up selected array if starting element was an input, and had a value;\n     * only used when the autocomplete first initialises\n     */\n    Autocomplete.prototype.prepSelectedFromArray = function (source) {\n        var _this = this;\n        var value = this.elementIsInput && this.element.value;\n        if (value && Array.isArray(source) && source.length) {\n            // account for multiple mode\n            var _a = this.options, multiple = _a.multiple, separator = _a.multipleSeparator;\n            var valueArr = multiple ? value.split(separator) : [value];\n            // create a shallow copy of the source to allow modifying\n            // (prepending entries in create mode)\n            var copiedSource_1 = source.slice();\n            valueArr.forEach(function (val) {\n                // make sure it is not already in the selected array\n                if (_this.indexOfValueIn(_this.selected, val, 'value') === -1) {\n                    // account for create mode\n                    _this.prependEntryInCreateMode(val, copiedSource_1);\n                    // confirm value is in the source array (check via 'value', not 'label')\n                    var indexInSource = _this.indexOfValueIn(copiedSource_1, val, 'value');\n                    if (indexInSource > -1) {\n                        _this.selected.push(copiedSource_1[indexInSource]);\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * adjust starting source array to format needed, and set selected\n     */\n    Autocomplete.prototype.prepListSourceArray = function () {\n        this.source = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceArray\"])(this.source, this.options.sourceMapping);\n        this.prepSelectedFromArray(this.source);\n    };\n    /**\n     * trigger source string endpoint to generate selected array\n     */\n    Autocomplete.prototype.prepListSourceAsync = function () {\n        var originalElement = this.element;\n        if (this.elementIsInput && originalElement.value) {\n            this.handleAsync(originalElement.value, true);\n        }\n    };\n    /**\n     * process source function to generate selected array\n     */\n    Autocomplete.prototype.prepListSourceFunction = function () {\n        var _this = this;\n        var originalElement = this.element;\n        if (!this.elementIsInput || !originalElement.value) {\n            return;\n        }\n        var render = function (response) {\n            var processedSource = Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"processSourceArray\"])(response, _this.options.sourceMapping);\n            _this.prepSelectedFromArray(processedSource);\n            _this.setInputStartingStates(false);\n        };\n        // check for `then` function on the result to allow use of a promise\n        var result = this.source.call(undefined, originalElement.value, render, true);\n        if (result && typeof result.then === 'function') {\n            result.then(function (response) { return render(response); });\n        }\n    };\n    /**\n     * adjust set sources to needed format\n     */\n    Autocomplete.prototype.prepListSource = function () {\n        // allow complete control over the source handling via custom function\n        if (typeof this.source === 'function') {\n            return this.prepListSourceFunction();\n        }\n        // string source - treat as async endpoint\n        if (typeof this.source === 'string' && this.source.length) {\n            return this.prepListSourceAsync();\n        }\n        // array source - copy array\n        if (Array.isArray(this.source) && this.source.length) {\n            return this.prepListSourceArray();\n        }\n        // dropdown source\n        this.sourceFromSelect = this.element.nodeName === 'SELECT';\n        if (this.sourceFromSelect) {\n            return this.prepListSourceDdl();\n        }\n        // checkboxlist source\n        this.sourceFromCheckboxList = !!this.element.querySelector('input[type=\"checkbox\"]');\n        if (this.sourceFromCheckboxList) {\n            return this.prepListSourceCheckboxes();\n        }\n        // defensive fallback\n        this.source = [];\n    };\n    /**\n     * set input starting states - aria attributes, disabled state, starting value\n     */\n    Autocomplete.prototype.setInputStartingStates = function (setAriaAttrs) {\n        if (setAriaAttrs === void 0) { setAriaAttrs = true; }\n        if (setAriaAttrs) {\n            // update corresponding label to now focus on the new input\n            if (this.label) {\n                this.label[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"ORIGINALLY_LABEL_FOR_PROP\"]] = this.ids.ELEMENT;\n                this.label.setAttribute('for', this.ids.INPUT);\n            }\n            // update aria-describedby and aria-labelledby attributes if present\n            var describedBy = this.element.getAttribute('aria-describedby');\n            if (describedBy) {\n                this.input.setAttribute('aria-describedby', describedBy);\n            }\n            var labelledBy = this.element.getAttribute('aria-labelledby');\n            if (labelledBy) {\n                this.input.setAttribute('aria-labelledby', labelledBy);\n            }\n        }\n        // if selected item(s) already exists\n        if (this.selected.length) {\n            // for multi select variant, set selected items\n            if (this.multiple) {\n                this.buildMultiSelected();\n                this.triggerAutoGrow();\n            }\n            // for single select variant, set value to match\n            else {\n                this.setInputValue(this.selected[0].label || '', true);\n            }\n        }\n        // disable the control if the invoked element was disabled\n        if (!!this.element.disabled) {\n            this.disable(true);\n        }\n    };\n    /**\n     * build and insert component html structure\n     */\n    Autocomplete.prototype.setHtml = function () {\n        var o = this.options;\n        var cssName = this.cssNameSpace;\n        var wrapperClass = o.wrapperClassName ? \" \" + o.wrapperClassName : '';\n        var newHtml = [\"<div id=\\\"\" + this.ids.WRAPPER + \"\\\" class=\\\"\" + cssName + \"__wrapper\" + wrapperClass + \"\\\">\"];\n        // add element for added screen reader announcements\n        // added before the main input, so that if screen reader users navigate past the input\n        // they will not encounter this element out of context\n        newHtml.push(\"<p class=\\\"sr-only \" + cssName + \"__sr-only \" + cssName + \"__sr-announcements\\\" \" +\n            (\"id=\\\"\" + this.ids.SR_ANNOUNCEMENTS + \"\\\" aria-live=\\\"polite\\\" aria-atomic=\\\"true\\\"></p>\"));\n        // add input\n        var name = o.name ? \" name=\\\"\" + o.name + \"\\\"\" : \"\";\n        var inputClass = o.inputClassName ? \" \" + o.inputClassName : '';\n        var placeholder = o.placeholder\n            ? \" placeholder=\\\"\" + o.placeholder + \"\\\" aria-placeholder=\\\"\" + o.placeholder + \"\\\"\"\n            : '';\n        newHtml.push(\"<input type=\\\"text\\\" autocomplete=\\\"off\\\" aria-expanded=\\\"false\\\" \" +\n            (\"aria-autocomplete=\\\"list\\\" aria-describedby=\\\"\" + this.ids.SR_ASSISTANCE + \"\\\" \") +\n            (\"role=\\\"combobox\\\" id=\\\"\" + this.ids.INPUT + \"\\\" aria-owns=\\\"\" + this.ids.LIST + \"\\\" \") +\n            (\"class=\\\"\" + cssName + \"__input\" + inputClass + \"\\\"\" + name + placeholder + \" />\"));\n        // button to show all available options\n        if (o.showAllControl) {\n            newHtml.push(\"<span role=\\\"button\\\" tabindex=\\\"0\\\" id=\\\"\" + this.ids.BUTTON + \"\\\" \" +\n                (\"aria-label=\\\"\" + o.srShowAllText + \"\\\" class=\\\"\" + cssName + \"__show-all\\\" \") +\n                (\"aria-describedby=\\\"\" + this.ids.LABEL + \"\\\" aria-expanded=\\\"false\\\"></span>\"));\n        }\n        // add the list holder\n        var explainerText = o.srListLabelText;\n        var listClass = o.listClassName ? \" \" + o.listClassName : '';\n        var explainer = explainerText ? \" aria-label=\\\"\" + explainerText + \"\\\"\" : '';\n        newHtml.push(\"<ul id=\\\"\" + this.ids.LIST + \"\\\" class=\\\"\" + cssName + \"__list\" + listClass + \"\\\" \" +\n            (\"role=\\\"listbox\\\" aria-describedby=\\\"\" + this.ids.LABEL + \"\\\" \") +\n            (\"aria-hidden=\\\"true\\\" hidden=\\\"hidden\\\"\" + explainer + \"></ul>\"));\n        // add the screen reader assistance element\n        newHtml.push(\"<p id=\\\"\" + this.ids.SR_ASSISTANCE + \"\\\" style=\\\"display:none;\\\">\" + Object(_autocomplete_helpers__WEBPACK_IMPORTED_MODULE_9__[\"escapeHtml\"])(o.srAssistiveText) + \"</p>\");\n        // close all and append\n        newHtml.push(\"</div>\");\n        this.element.insertAdjacentHTML('afterend', newHtml.join(''));\n    };\n    /**\n     * destroy component\n     */\n    Autocomplete.prototype.destroy = function () {\n        var _this = this;\n        // return original label 'for' attribute back to element id\n        if (this.label && this.label[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"ORIGINALLY_LABEL_FOR_PROP\"]]) {\n            this.label.setAttribute('for', this.label[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"ORIGINALLY_LABEL_FOR_PROP\"]]);\n            delete this.label[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"ORIGINALLY_LABEL_FOR_PROP\"]];\n        }\n        // remove the document click if still bound\n        if (this.documentClickBound) {\n            document.removeEventListener('click', this.documentClick);\n        }\n        // destroy autogrow behaviour and events\n        if (this.autoGrow && this.inputAutoWidth) {\n            this.inputAutoWidth.destroy();\n        }\n        // remove the whole wrapper\n        this.wrapper.parentNode.removeChild(this.wrapper);\n        delete this.element[_autocomplete_constants__WEBPACK_IMPORTED_MODULE_8__[\"API_STORAGE_PROP\"]];\n        // re-show original element\n        this.show(this.element);\n        // clear timers\n        clearTimeout(this.filterTimer);\n        clearTimeout(this.pollingTimer);\n        clearTimeout(this.showAllPrepTimer);\n        clearTimeout(this.announcementTimer);\n        clearTimeout(this.componentBlurTimer);\n        clearTimeout(this.clearAnnouncementTimer);\n        clearTimeout(this.elementChangeEventTimer);\n        // clear stored element vars\n        [\n            'list',\n            'input',\n            'label',\n            'element',\n            'wrapper',\n            'showAll',\n            'deleteAll',\n            'srAssistance',\n            'srAnnouncements',\n        ].forEach(function (entry) { return (_this[entry] = null); });\n    };\n    /**\n     * initialise AriaAutocomplete\n     */\n    Autocomplete.prototype.init = function (element, options) {\n        this.selected = [];\n        this.element = element;\n        this.label = document.querySelector('[for=\"' + this.element.id + '\"]');\n        this.ids = new _autocomplete_ids__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.element.id, this.label ? this.label.id : null, options.id);\n        this.elementIsInput = element.nodeName === 'INPUT';\n        this.options = new _autocomplete_options__WEBPACK_IMPORTED_MODULE_4__[\"default\"](options);\n        // ensure label has an id, for use in `aria-describedby` attributes later\n        if (this.label && !this.label.id) {\n            this.label.id = this.ids.LABEL;\n        }\n        // set these internally so that the component has to be properly destroyed to change them\n        this.source = this.options.source;\n        this.multiple = this.options.multiple;\n        this.autoGrow = this.options.autoGrow;\n        this.cssNameSpace = this.options.cssNameSpace;\n        this.documentClick = this.handleComponentBlur.bind(this);\n        // create html structure\n        this.setHtml();\n        // set main element vars\n        this.list = document.getElementById(this.ids.LIST);\n        this.input = document.getElementById(this.ids.INPUT);\n        this.wrapper = document.getElementById(this.ids.WRAPPER);\n        this.showAll = document.getElementById(this.ids.BUTTON);\n        this.srAssistance = document.getElementById(this.ids.SR_ASSISTANCE);\n        this.srAnnouncements = document.getElementById(this.ids.SR_ANNOUNCEMENTS);\n        // set internal source array, from static elements if necessary\n        this.prepListSource();\n        // set any further classes on component wrapper based on options\n        var wrapperClassesToAdd = [];\n        if (this.options.showAllControl) {\n            wrapperClassesToAdd.push(this.cssNameSpace + \"__wrapper--show-all\");\n        }\n        if (this.autoGrow) {\n            wrapperClassesToAdd.push(this.cssNameSpace + \"__wrapper--autogrow\");\n        }\n        if (this.multiple) {\n            wrapperClassesToAdd.push(this.cssNameSpace + \"__wrapper--multiple\");\n        }\n        if (wrapperClassesToAdd.length) {\n            Object(element_addclass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.wrapper, wrapperClassesToAdd.join(' '));\n        }\n        // hide element and list manually\n        this.hide(this.list); // pass in the list so that the onClose is not triggered\n        this.hide(this.element);\n        // set starting states for input - must be after source has been defined\n        this.setInputStartingStates();\n        // bind all necessary events\n        this.bindEvents();\n        // generate api object to expose\n        // do this before onready, so that its context is correct\n        this.api = new _autocomplete_api__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this);\n        // fire onready callback\n        this.triggerOptionCallback('onReady', [this.wrapper]);\n    };\n    return Autocomplete;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Autocomplete);\n\n\n//# sourceURL=webpack:///./src/autocomplete.ts?");

/***/ }),

/***/ "./src/closest-polyfill.ts":
/*!*********************************!*\
  !*** ./src/closest-polyfill.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var elemProto = Element.prototype;\nif (!elemProto.matches) {\n    elemProto.matches = elemProto['msMatchesSelector'] || elemProto['webkitMatchesSelector'];\n}\nif (!elemProto.closest) {\n    elemProto.closest = function (s) {\n        var el = this;\n        do {\n            if (el.matches(s))\n                return el;\n            el = el.parentElement || el.parentNode;\n        } while (el !== null && el.nodeType === 1);\n        return null;\n    };\n}\n\n\n//# sourceURL=webpack:///./src/closest-polyfill.ts?");

/***/ })

/******/ });
});